* NodeJs :
    - JS runtime environment ( execute JS code outside the browser)
    - NodeJs is C++ program and needs V8 engine to understand JS code that’s why you will find V8 folder in dependencies 
    - NodeJs is C++ program so you can combine between features in JS and Features in C++
    - Lib folder in dependencies help developers to access C++ features from JS 
    - In NodeJs you don’t have access to web Api

* Modules :
    A module is an encapsulated and reusable chunk of code that has its own context
    In Node.js, each file is treated as a separate module
    Types of Modules :
        1.Local modules - Modules that we create in our application ( like commonJs and ES module)
        2.Built-in modules - Modules that Node.js ships with out of the box
        3.Third party modules - Modules written by other developers that we can use in our application

* commonJs Module (require) : 
    require() is a built-in function to include external modules that exist in separate files. 
    require() statement basically reads a JavaScript file, executes it , 
    and return the module.exports object. ( require("./add.js") has the value of module.exports = add; in add.js file )

* Module Scope :
    Each loaded module in Node.js is wrapped with an IIFE that provides private scoping of code
    IIFE allows you to repeat variable or function names without any conflicts 
    (batman.js and superman.js has same variable name (superhero) and no conflict when we used require in index.js)
    * under the hood when you write require("./batman") and require("./superman") in index.js
    node will wrap then with IIFE ( you can see exp. of wrapping like in iife.js)
    * under the hood node inject 5 arguments (exports, require, module,__filename,__dirname ) when wrap module by iife

* difference between module.exports and exports ?
    module.exports is an object (which's returned from require() ) and exports just a reference to this object
    
    [1] when you write exports = superhero; in superman.js and try to console.log(require("./superman)) 
        - module.exports = {};
        - let exports = module.exports; now exports reference to module.exports object
        - exports = superhero; now you overwrite exports and break the reference
        - console.log(require("./superman)); will give you {}
    [2]  when you write exports.superhero = superhero; in superman.js and try to console.log(require("./superman))
        - module.exports = {}
        - let exports = module.exports; now exports reference to module.exports object
        - exports.superman = superhero; now same reference and you added superman property to same object
        - console.log(require("./superman)); will give you {superman : "Superman"}
    [3] when you write module.exports = superhero; in batman.js and try to console.log(require("./batman))
        - module.exports = {}
        - let exports = module.exports;
        - module.exports = superhero;
        - console.log(require("./superman)); will give you "Batman"


* ES Module : 
    if you want to use ES Module (export and import) instead of using commonJs ( module.exports and require())
    name file extension mjs ( like main.mjs and math.mjs)

* Importing JSON File : 
    when you create JSON file ( data.json ) you can use require("./data") directly no need to add module.exports = data; in JSON file
    and require will parse json data to js object automatically

* watch mode in nodeJs :
    supported from version 18 (node --watch file name)

* built-n Module ( path , events , fs , stream , http )

* Path check index.js

* Events (Built-in) : 
    steps : 
    [1] import EventEmitter Class const EventEmitter = require("node:events");
    [2] create emitter instance from EventEmitter Class ( emitter instance has on and emitt methods)
    [3] emitter.on (like addEventListener )
    [4] emitter.emitt ( like click or disptaching the event ) ( you can add arguments starting from 2nd parameters)

* Extend with buil-in Event check index.js

* To understand Character set , Encoding, Streams and buffer watch these Videos : 
    https://youtu.be/0LYXkL0pr1M?si=-HtSPPEvMQqL6kz0
    https://youtu.be/br8VB99qPzE?si=hzlOvXD3RO8_kPP2

* fs(file system) ( check Exp. in index.js) :
    * NodeJs has built-in Async methods ( like fs.readFile() or fs.writeFile() )  not like JS needs browsers or Web Api to do Async
    * fs.writeFile() method by default will overwrite any content in file so we can add {flag: "a",}
        to append to the file not to overwrite
    * promise with fs : performance in regular fs is better than fs promise (check Exp. in index.js)

* Stream :
    - is a sequence of data that is being moved from one point to another over time
    - Stream is infact a built-in node module that inherits from the event emitter class 
        that’s why readableStream has on method ( inherited it from event emitter class)

    - Types of Streams
        [1] Readable streams from which data can be read Ex: Reading from a file as readable stream
        [2] Writable streams to which we can write data Ex: Writing to a file as writable stream
        [3] Duplex streams that are both Readable and Writable Ex: Sockets as a duplex stream
        [4] Transform streams that can modify or transform the data as it is written and read 
            Ex: File compression where you can write compressed data and read de-compressed data to and from a file as a transform stream

    - default chunk size if 64 bits but you can change this by addin highWaterMark: 2 (2bits) to options object 
    - data event will be fired automatically ( no need to emitt it ) when data is received
    - you can use pipe method instead of data event ( check exp. in index.js)
    - chained pipe ( works only with specific destination stream types : readable , duplex or transform Streams)
    
* HTTP Module :
    - HTTP module extend EventEmitter Class 
    - const server = http.createServer((request , response) => {}) 
        To create server and accept callback function as argument 
        This callback function request event listener 
        Means when the server get request this callback function will be executed
    - server.listen() to tell server to start listening at which port 
        and can accept 2nd argument as callback function which will be executed when server start listening 
    - response.end() accepts only type string or an instance of Buffer or Uint8Array.
        So we use JSON.stringify() and we should add {"Content-Type" : "application/json"}
    - to send html response we should add {"Content-Type" : "text/html"}
    - you can send whole html file as a response like res.end(fs.readFileSync("./index.html"))
    - using pipe is better performance than fs.readFileSync
        fs.createReadStream("./index.html").pipe(res) 
        is better than 
        res.end(fs.readFileSync("./index.html"))
    - if you want to add dynamic html ( for exp. add name from server to html file before send it as response) ( you can't use here pipe)
        [1] let html = fs.readFileSync("./index.html" , "utf-8")
        [2] const name = "Soliman"
        [3] html = html.replace("{{name}}" , name) // string replace method
        [4] res.end(html)

* Routing (check index.js)

* Thread Pool
    - Libuv thread pool as the name indicates is literally a pool of threads, 
    that NodeJS uses to offload time-consuming tasks ( like crypto.pbkdf2 ) 
    and ensures the main thread is not blocked for a long time (Asynchronous)
    
    - videos to understand better :
        https://youtu.be/I1sqnbJ1Fno?si=wCKSOM-EPqNCE610
        https://youtu.be/I1sqnbJ1Fno?si=fLkMJOxOy7sXRr5z 

    - you can change Thread pool size by ( process.env.UV_THREADPOOL_SIZE = 16;)
        * note : each thread take one cpu core from your laptop 
            for exp. if you have 4 cpu cores so for best performance make size of Thread pool to 4
            if you make size of thread pool to 8 so each core will take 2 threads so will not give you best performance


